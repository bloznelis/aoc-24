(*type direction = Up | Right | Down | Left [@@deriving compare]*)
(*type reindeer = { pos : int * int; dir : direction }*)
(*type state = { reindeer : reindeer; cost : int }*)
(**)
(*let turn_left state =*)
(*  {*)
(*    reindeer =*)
(*      {*)
(*        state.reindeer with*)
(*        dir =*)
(*          (match state.reindeer.dir with Up -> Left | Right -> Up | Down -> Right | Left -> Down);*)
(*      };*)
(*    cost = state.cost + 1000;*)
(*  }*)
(**)
(*let turn_right state =*)
(*  {*)
(*    reindeer =*)
(*      {*)
(*        state.reindeer with*)
(*        dir =*)
(*          (match state.reindeer.dir with Up -> Right | Right -> Down | Down -> Left | Left -> Up);*)
(*      };*)
(*    cost = state.cost + 1000;*)
(*  }*)
(**)
(*let forward state matrix =*)
(*  let x, y = state.reindeer.pos in*)
(*  let next_pos =*)
(*    match state.reindeer.dir with*)
(*    | Up -> (x, y - 1)*)
(*    | Right -> (x + 1, y)*)
(*    | Down -> (x, y + 1)*)
(*    | Left -> (x - 1, y)*)
(*  in*)
(*  Util.safe_get_a next_pos matrix*)
(*  |> Option.map (fun _ ->*)
(*         { reindeer = { state.reindeer with pos = next_pos }; cost = state.cost + 1 })*)
(**)
(*let possibilities state matrix =*)
(*  Base.List.filter_opt*)
(*    [ forward (turn_left state) matrix; forward (turn_right state) matrix; forward state matrix ]*)
(**)
(*let update_hashtable table key value =*)
(*  match Hashtbl.find_opt table key with*)
(*  | Some existing_value -> if value < existing_value then Hashtbl.replace table key value else ()*)
(*  | None -> Hashtbl.add table key value*)
(**)
(**)
(*module IntInt =*)
(*  struct*)
(*   type t = int * int*)
(*   let compare = compare*)
(*  end*)
(**)
(*module PairSet = Set.Make(IntInt)*)
(**)
(**)
(*let solve start_pos end_pos matrix =*)
(*  let table = Hashtbl.create 10000 in*)
(*  let rec go state work =*)
(*    let memed = Hashtbl.find_opt table state.reindeer in*)
(*    match memed with*)
(*    | Some value -> print_endline "hit"; value*)
(*    | None ->*)
(*        print_endline (Util.tuple_to_string state.reindeer.pos);*)
(*        if state.reindeer.pos = end_pos then state.cost*)
(*        else*)
(*          let choices = possibilities state matrix in*)
(*          let cheapest = List.map go choices |> Base.List.min_elt ~compare |> Option.get in*)
(*          update_hashtable table state.reindeer cheapest;*)
(*          cheapest*)
(*  in*)
(*  go { reindeer = { pos = start_pos; dir = Up }; cost = 0 }*)
(**)
(*let parse_map input : char array array =*)
(*  Base.String.split_lines input*)
(*  |> Base.List.take_while ~f:(fun line -> Base.String.is_empty line |> Bool.not)*)
(*  |> List.map (fun line -> Base.String.to_array line)*)
(*  |> Array.of_list*)
(**)
(*let find_char_coords char_to_find matrix =*)
(*  Array.find_mapi*)
(*    (fun y line ->*)
(*      Array.find_mapi (fun x char -> if char = char_to_find then Some (x, y) else None) line)*)
(*    matrix*)
(*  |> Option.get*)
(**)
(*let part1 input =*)
(*  let matrix = parse_map input in*)
(*  let start_pos = find_char_coords 'S' matrix in*)
(*  let end_pos = find_char_coords 'E' matrix in*)
(*  let answer = solve start_pos end_pos matrix in*)
(*  answer |> string_of_int*)
(**)
(*let part2 input = input*)
